<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="/ProAssist.png" />
    <title>Audience Display - ProAssist</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100vw;
            height: 100vh;
            position: relative;
            overflow: hidden;
            color: #ffffff;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }

        .text-box {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 8px;
            overflow: hidden;
        }

        .text-content {
            line-height: 1.2;
            white-space: pre-wrap;
            word-break: break-word;
            width: 100%;
        }

        .reference-box {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 6px;
            overflow: hidden;
        }

        .reference-content {
            line-height: 1.1;
            white-space: pre-wrap;
            word-break: break-word;
            width: 100%;
        }

        .connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 8px 12px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 6px;
            font-size: 0.85rem;
            z-index: 10000;
            display: flex;
            align-items: center;
            gap: 8px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        body:hover .connection-status {
            opacity: 1;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #ef4444;
        }

        .status-indicator.connected {
            background-color: #22c55e;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>
</head>
<body>
    <div class="connection-status">
        <div class="status-indicator" id="statusIndicator"></div>
        <span id="statusText">Connecting...</span>
    </div>

    <div class="text-box" id="textBox" style="display: none;">
        <div class="text-content" id="textContent"></div>
    </div>

    <div class="reference-box" id="referenceBox" style="display: none;">
        <div class="reference-content" id="referenceContent"></div>
    </div>

    <script>
        let ws = null;
        let scripture = { verseText: '', reference: '' };
        let settings = {
            backgroundColor: '#000000',
            backgroundImagePath: '',
            textFont: 'system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif',
            referenceFont: 'system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif',
            textStyle: {
                color: '#ffffff',
                bold: false,
                italic: false,
                stroke: undefined,
                shadow: undefined,
            },
            referenceStyle: {
                color: '#ffffff',
                bold: false,
                italic: false,
                stroke: undefined,
                shadow: undefined,
            },
            layout: {
                text: { x: 0.08, y: 0.1, width: 0.84, height: 0.6 },
                reference: { x: 0.08, y: 0.75, width: 0.84, height: 0.16 },
            },
        };
        let backgroundImageUrl = '';

        function updateConnectionStatus(connected) {
            const indicator = document.getElementById('statusIndicator');
            const text = document.getElementById('statusText');
            if (connected) {
                indicator.classList.add('connected');
                text.textContent = 'Connected';
            } else {
                indicator.classList.remove('connected');
                text.textContent = 'Disconnected';
            }
        }

        function getFontStyle(style) {
            const css = {
                color: style.color,
                fontWeight: style.bold ? 'bold' : 'normal',
                fontStyle: style.italic ? 'italic' : 'normal',
            };

            if (style.stroke) {
                css.webkitTextStroke = `${style.stroke.width}px ${style.stroke.color}`;
                css.textStroke = `${style.stroke.width}px ${style.stroke.color}`;
            }

            if (style.shadow) {
                css.textShadow = `${style.shadow.offsetX}px ${style.shadow.offsetY}px ${style.shadow.blur}px ${style.shadow.color}`;
            }

            return css;
        }

        function applyStyles(element, styles) {
            Object.assign(element.style, styles);
        }

        function rectStyle(rect) {
            return {
                left: `${rect.x * 100}%`,
                top: `${rect.y * 100}%`,
                width: `${rect.width * 100}%`,
                height: `${rect.height * 100}%`,
            };
        }

        function autoFontSize(boxElement, contentElement, text, minSize = 14, maxSize = 220) {
            if (!text || !boxElement || !contentElement) return minSize;

            // Get container dimensions (accounting for padding)
            const computedStyle = window.getComputedStyle(boxElement);
            const paddingH = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);
            const paddingV = parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.paddingBottom);
            const containerWidth = boxElement.clientWidth - paddingH;
            const containerHeight = boxElement.clientHeight - paddingV;
            
            if (containerWidth <= 0 || containerHeight <= 0) return minSize;

            // Binary search for optimal font size
            let low = minSize;
            let high = maxSize;
            let best = minSize;

            while (low <= high) {
                const mid = Math.floor((low + high) / 2);
                contentElement.style.fontSize = `${mid}px`;
                
                // Force a reflow to get accurate measurements
                void contentElement.offsetWidth;
                
                // Check if content fits within container
                const fits = contentElement.scrollWidth <= containerWidth && 
                             contentElement.scrollHeight <= containerHeight;

                if (fits) {
                    best = mid;
                    low = mid + 1;
                } else {
                    high = mid - 1;
                }
            }

            // Set final font size
            contentElement.style.fontSize = `${best}px`;
            return best;
        }

        function updateDisplay() {
            // Update background
            document.body.style.backgroundColor = settings.backgroundColor;
            if (backgroundImageUrl) {
                document.body.style.backgroundImage = `url(${backgroundImageUrl})`;
                document.body.style.backgroundSize = 'cover';
                document.body.style.backgroundPosition = 'center';
            } else {
                document.body.style.backgroundImage = '';
            }

            // Update text box
            const textBox = document.getElementById('textBox');
            const textContent = document.getElementById('textContent');
            
            if (scripture.verseText) {
                textBox.style.display = 'flex';
                applyStyles(textBox, rectStyle(settings.layout.text));
                textContent.textContent = scripture.verseText;
                textContent.style.fontFamily = settings.textFont;
                applyStyles(textContent, getFontStyle(settings.textStyle));
                
                // Auto font size - use requestAnimationFrame to ensure layout is complete
                requestAnimationFrame(() => {
                    autoFontSize(textBox, textContent, scripture.verseText, 14, 220);
                });
            } else {
                textBox.style.display = 'none';
            }

            // Update reference box
            const referenceBox = document.getElementById('referenceBox');
            const referenceContent = document.getElementById('referenceContent');
            
            if (scripture.reference) {
                referenceBox.style.display = 'flex';
                applyStyles(referenceBox, rectStyle(settings.layout.reference));
                referenceContent.textContent = scripture.reference;
                referenceContent.style.fontFamily = settings.referenceFont;
                applyStyles(referenceContent, getFontStyle(settings.referenceStyle));
                
                // Auto font size - use requestAnimationFrame to ensure layout is complete
                requestAnimationFrame(() => {
                    autoFontSize(referenceBox, referenceContent, scripture.reference, 12, 160);
                });
            } else {
                referenceBox.style.display = 'none';
            }
        }

        function loadBackgroundImage(imageUrl) {
            if (!imageUrl) {
                backgroundImageUrl = '';
                updateDisplay();
                return;
            }

            // Accept data URLs, http/https URLs
            if (imageUrl.startsWith('http://') || imageUrl.startsWith('https://') || imageUrl.startsWith('data:')) {
                backgroundImageUrl = imageUrl;
                updateDisplay();
            } else {
                // Local file paths won't work in the browser - clear it
                backgroundImageUrl = '';
                updateDisplay();
            }
        }

        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;
            
            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log('WebSocket connected');
                updateConnectionStatus(true);
                
                // Send join message for display updates
                ws.send(JSON.stringify({
                    type: 'join_display'
                }));
            };

            ws.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    if (message.type === 'display_update') {
                        scripture = {
                            verseText: message.scripture?.verse_text || '',
                            reference: message.scripture?.reference || '',
                        };
                        if (message.settings) {
                            // Merge settings, preserving defaults
                            settings = {
                                ...settings,
                                ...message.settings,
                                textStyle: message.settings.textStyle ? { ...settings.textStyle, ...message.settings.textStyle } : settings.textStyle,
                                referenceStyle: message.settings.referenceStyle ? { ...settings.referenceStyle, ...message.settings.referenceStyle } : settings.referenceStyle,
                                layout: message.settings.layout ? { ...settings.layout, ...message.settings.layout } : settings.layout,
                            };
                            // Use backgroundImageDataUrl for web display (data URL sent from app)
                            if (message.settings.backgroundImageDataUrl) {
                                loadBackgroundImage(message.settings.backgroundImageDataUrl);
                            } else if (message.settings.backgroundImageDataUrl === '' || 
                                       (message.settings.backgroundImagePath === '' && !message.settings.backgroundImageDataUrl)) {
                                backgroundImageUrl = '';
                            }
                        }
                        updateDisplay();
                    }
                } catch (error) {
                    console.error('Error parsing WebSocket message:', error);
                }
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                updateConnectionStatus(false);
            };

            ws.onclose = () => {
                console.log('WebSocket disconnected');
                updateConnectionStatus(false);
                // Attempt to reconnect after 3 seconds
                setTimeout(connectWebSocket, 3000);
            };
        }

        // Initial load
        connectWebSocket();

        // Update display on window resize
        window.addEventListener('resize', () => {
            updateDisplay();
        });
    </script>
</body>
</html>
